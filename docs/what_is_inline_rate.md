# 什么是内联率？

## 简单解释

**内联率 = 能够直接存储在栈上（不需要堆分配）的字符串所占的百分比**

---

## SmolStr 的内部机制

### SmolStr 的两种存储方式

```rust
pub enum SmolStr {
    // 方式 1: 内联存储（Inline）- 存储在栈上
    Inline {
        len: u8,           // 长度：1 字节
        buf: [u8; 23],     // 数据：23 字节
    },                     // 总共：24 字节

    // 方式 2: Arc 存储 - 存储在堆上
    Arc(Arc<str>),         // 指针：8 字节（指向堆上的数据）
}
```

### 判断规则

```rust
let s = "some string";

if s.len() <= 22 {
    // ✅ 内联存储（快）
    SmolStr::Inline { len: s.len(), buf: [...] }
} else {
    // ❌ 堆存储（慢）
    SmolStr::Arc(Arc::from(s))
}
```

**关键界限**：**22 字节**

---

## 可视化对比

### 示例 1: 短字符串 "192.168.1.1" (11 字节)

#### SmolStr (内联存储)
```
栈内存：
┌─────────────────────────────────────┐
│ SmolStr::Inline                     │
│ ┌─────┬───────────────────────────┐ │
│ │ len │ "192.168.1.1\0\0\0..."    │ │
│ │ 11  │ (23 字节缓冲区)           │ │
│ └─────┴───────────────────────────┘ │
└─────────────────────────────────────┘
总占用: 24 字节 (全在栈上)
创建速度: ⚡⚡⚡ 极快 (栈拷贝)
```

#### ArcStr (堆存储)
```
栈内存：                堆内存：
┌──────────┐           ┌──────────────┐
│ ArcStr   │  ───────> │ refcount: 1  │
│ (指针)   │           │ "192.168.1.1"│
└──────────┘           └──────────────┘
栈占用: 8 字节          堆占用: ~20 字节
创建速度: ⚡ 需要堆分配
```

**对比**：
- SmolStr：24B 栈，0B 堆，创建快 **2-3x** ✅
- ArcStr：8B 栈，~20B 堆，创建慢

---

### 示例 2: 长字符串 "Mozilla/5.0 (Windows NT 10.0; Win64; x64)..." (50 字节)

#### SmolStr (堆存储)
```
栈内存：                堆内存：
┌──────────┐           ┌──────────────────────────┐
│ SmolStr  │  ───────> │ refcount: 1              │
│ ::Arc    │           │ "Mozilla/5.0 (Windows..." │
│ (指针)   │           │ (50 字节)                 │
└──────────┘           └──────────────────────────┘
栈占用: 8 字节          堆占用: ~58 字节
创建速度: ⚡ 需要堆分配 + 长度检查
```

#### ArcStr (堆存储)
```
栈内存：                堆内存：
┌──────────┐           ┌──────────────────────────┐
│ ArcStr   │  ───────> │ refcount: 1              │
│ (指针)   │           │ "Mozilla/5.0 (Windows..." │
└──────────┘           │ (50 字节)                 │
                       └──────────────────────────┘
栈占用: 8 字节          堆占用: ~58 字节
创建速度: ⚡ 需要堆分配
```

**对比**：
- SmolStr：与 ArcStr 相同，但多了长度检查 ⚠️
- ArcStr：直接堆分配

---

## 什么是内联率？

### 定义

```
内联率 = (长度 ≤ 22 字节的字符串数量) / (总字符串数量) × 100%
```

### 示例计算

假设有 10 个字段值：

```rust
let values = vec![
    "192.168.1.1",              // 11B  ✅ 可内联
    "GET",                      // 3B   ✅ 可内联
    "200",                      // 3B   ✅ 可内联
    "/api/login",               // 11B  ✅ 可内联
    "user_12345",               // 10B  ✅ 可内联
    "2024-01-01T00:00:00.123Z", // 24B  ❌ 不可内联（超过 22B）
    "session_xyz123abc456def",  // 24B  ❌ 不可内联
    "Mozilla/5.0 ...",          // 120B ❌ 不可内联
    "https://api.example.com/...", // 50B ❌ 不可内联
    "INFO",                     // 4B   ✅ 可内联
];
```

**计算**：
- 可内联：6 个（≤ 22 字节）
- 不可内联：4 个（> 22 字节）
- **内联率 = 6 / 10 = 60%**

---

## 内联率的重要性

### 高内联率（> 70%）- SmolStr 优势明显

**示例场景**：Nginx 访问日志

```rust
// 9 个字段值
let values = vec![
    "222.133.52.20",        // 14B ✅
    "GET",                  // 3B  ✅
    "/nginx-logo.png",      // 16B ✅
    "HTTP/1.1",             // 8B  ✅
    "200",                  // 3B  ✅
    "368",                  // 3B  ✅
    "http://119.122.1.4/",  // 20B ✅
    "[06/Aug/2019:...]",    // 29B ❌
    "Mozilla/5.0 ...",      // 120B ❌
];
// 内联率 = 7/9 = 78%
```

**性能影响**：
- 78% 的字段值创建速度提升 **2-3x** ⚡⚡⚡
- 22% 的字段值性能持平或略降 ⚠️
- **整体创建性能提升约 +50-70%**

---

### 低内联率（< 50%）- SmolStr 优势不明显

**示例场景**：JSON 应用日志

```rust
// 9 个字段值
let values = vec![
    "INFO",                          // 4B   ✅
    "login",                         // 5B   ✅
    "req_abcdef1234567890",         // 21B  ✅
    "2024-01-01T00:00:00.123Z",     // 24B  ❌
    "user_a1b2c3d4e5f6g7h8",        // 23B  ❌
    "session_xyz123abc456def789",   // 28B  ❌
    "device_mobile_ios_12345",      // 24B  ❌
    "User logged in successfully...", // 44B ❌
    "https://api.example.com/...",  // 90B  ❌
];
// 内联率 = 3/9 = 33%
```

**性能影响**：
- 33% 的字段值创建速度提升 **2-3x** ⚡
- 67% 的字段值性能持平或略降 ⚠️
- **整体创建性能提升约 +10-20%**
- **但内存占用增加约 2x** ⚠️⚠️

---

## 22 字节界限的实际意义

### 能内联的常见字符串

| 类型 | 示例 | 长度 | 能否内联? |
|------|------|------|----------|
| **IP 地址** | `192.168.1.1` | 11B | ✅ |
| **IPv6** | `2001:db8::1` | 11B | ✅ |
| **HTTP 方法** | `GET`, `POST` | 3-4B | ✅ |
| **状态码** | `200`, `404` | 3B | ✅ |
| **路径（短）** | `/api/login` | 11B | ✅ |
| **用户名（短）** | `user_12345` | 10B | ✅ |
| **日期（短格式）** | `2024-01-01` | 10B | ✅ |

### 不能内联的常见字符串

| 类型 | 示例 | 长度 | 能否内联? |
|------|------|------|----------|
| **ISO 时间戳** | `2024-01-01T00:00:00.123Z` | 24B | ❌ |
| **Session ID** | `session_xyz123abc456def789` | 28B | ❌ |
| **Trace ID** | `trace_1a2b3c4d5e6f7g8h9i0j` | 28B | ❌ |
| **URL** | `https://api.example.com/v1/users` | 35B | ❌ |
| **User-Agent** | `Mozilla/5.0 (Windows NT...)` | 120B | ❌ |
| **消息** | `User logged in successfully from device xyz` | 44B | ❌ |

---

## 如何测量你的实际内联率

### 方法 1: 代码统计

```rust
// 添加到你的日志解析器
let mut inline_count = 0;
let mut total_count = 0;

for field_value in all_field_values {
    total_count += 1;
    if field_value.len() <= 22 {
        inline_count += 1;
    }
}

let inline_rate = (inline_count as f64 / total_count as f64) * 100.0;
println!("内联率: {:.1}%", inline_rate);
```

### 方法 2: 分析样本日志

```rust
// 解析 1000 条真实日志
let sample_logs = read_sample_logs(1000);
let all_values: Vec<&str> = parse_all_field_values(&sample_logs);

let inline_count = all_values.iter()
    .filter(|v| v.len() <= 22)
    .count();

let inline_rate = (inline_count as f64 / all_values.len() as f64) * 100.0;
println!("样本内联率: {:.1}%", inline_rate);
```

---

## 决策指南

### 🟢 推荐使用 SmolStr

**条件**：内联率 > 70%

**典型场景**：
- Nginx/Apache 访问日志
- KV 格式日志（Syslog, CEF）
- 大部分是短字符串的场景

**预期收益**：
- 创建性能提升 **+60-100%**
- Clone 性能提升 **+30-50%**

### 🟡 需要 Benchmark 验证

**条件**：内联率 50-70%

**典型场景**：
- 混合日志类型
- 微服务日志

**建议**：
- 运行实际 benchmark 测试
- 评估性能提升 vs 内存占用

### 🔴 推荐使用 ArcStr

**条件**：内联率 < 50%

**典型场景**：
- JSON 应用日志为主
- 包含大量长字符串（URL, User-Agent, 消息）

**原因**：
- SmolStr 性能提升有限（+10-20%）
- 内存占用增加 **2x** ⚠️
- 不划算

---

## 总结

**内联率**就是：
- 能够直接存在栈上（≤22 字节）的字符串所占的百分比
- 决定 SmolStr 是否值得使用的**关键指标**

**简单记忆**：
- 内联率高（>70%）→ SmolStr 很快 ✅
- 内联率低（<50%）→ ArcStr 更好 ✅

**你的场景**：
- 字段名：基本都 ≤22B → SmolStr ✅（已完成）
- 字段值：需要实测 → 先用 ArcStr ✅（当前方案）

**需要帮助吗？**
我可以帮你写一个脚本来分析你的实际日志数据，计算真实的内联率！
